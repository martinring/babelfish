/*
 * THIS FILE IS AUTO GENERATED BY BABELFISH. YOU SHOULD NOT MODIFY IT!
 */

package de.dfki

import scala.scalajs.js
import scala.concurrent.{ Future, Promise }
import scala.collection.mutable
import scala.concurrent.ExecutionContext.Implicits.global

import Messages._

trait Client {
  def message(from: Person, content: String): Future[Int]
}

object Client {
  def remote(send: js.Any => Unit): (js.Any => Unit, Client) = {
    var id = 0
    var handlers = mutable.Map.empty[Int,Promise[js.Any]]
    def nextId() = { id += 1; id }    
    val impl = new Client {
      override def message(from: Person, content: String): Future[Int] = {
        val id = nextId()
        val msg = js.Dynamic.literal(
          "jsonrpc" -> "2.0",
          "method" -> "message",
          "params" -> js.Dynamic.literal(
            "from" -> Codec.write(from),
            "content" -> Codec.write(content)
          ),
          "id" -> id
        )
        send(msg)
        val handler = Promise[js.Any]
        handlers += id -> handler
        handler.future.map(Codec.read[Int])
      }
    }
    def receive(msg: js.Any): Unit = {
      val d = msg.asInstanceOf[js.Dictionary[js.Any]]
      for {
        id <- d.get("id").asInstanceOf[Option[Int]]
        result <- d.get("result")
        handler <- handlers.remove(id)
      } handler.success(result)     
    }
    (receive,impl)
  }

  def local(send: js.Any => Unit)(impl: Client): js.Any => Unit = { msg: js.Any =>    
    val d = msg.asInstanceOf[js.Dictionary[js.Any]]
    d.get("method").asInstanceOf[Option[String]].foreach {
      case "message" => 
        val result = for {
          params <- d.get("params").asInstanceOf[Option[js.Dictionary[js.Any]]]
          from <- params.get("from")
          content <- params.get("content")
        } yield impl.message(Codec.read[Person](from), Codec.read[String](content))
        result.foreach(res => res.foreach(res => send(Codec.write(res))))
    }
  }
}