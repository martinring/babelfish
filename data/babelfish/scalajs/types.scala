/*
 * THIS FILE IS AUTO GENERATED BY BABELFISH. YOU SHOULD NOT MODIFY IT!
 */

package $for(options.module)$$options.module$$sep$.$endfor$

import scala.scalajs.js

object $name.pascal$ {
$for(type)$
$if(type.plain)$
$for(type.constructor)$
  case class $type.name.pascal$(
$for(type.constructor.parameter)$
      $type.constructor.parameter.name.camel$: $type.constructor.parameter.type$$sep$,
$endfor$

    )
$endfor$
$else$
$if(type.enum)$
  sealed trait $type.name.pascal$
  object $type.name.pascal$ {
$for(type.constructor)$
    case object $type.constructor.name.pascal$ extends $type.name.pascal$
$endfor$
  }
$else$
  sealed trait $type.name.pascal$
  object $type.name.pascal$ {
$for(type.constructor)$
$if(type.constructor.empty)$
    case object $type.constructor.name.pascal$ extends $type.name.pascal$
$else$
    case class $type.constructor.name.pascal$(
$for(type.constructor.parameter)$
        $type.constructor.parameter.name.camel$: $type.constructor.parameter.type$$sep$,
$endfor$

      ) extends $type.name.pascal$
$endif$
$endfor$
  }
$endif$
$endif$
$sep$

$endfor$

  // Codec

  trait Codec[A] {
    def write(from: A): js.Any
    def read(from: js.Any): A
  }

  object Codec {
    def write[A](from: A)(implicit codec: Codec[A]): js.Any = codec.write(from)
    def read[A](from: js.Any)(implicit codec: Codec[A]): A = codec.read(from)
    def apply[A](w: A => js.Any, r: js.Any => A): Codec[A] = new Codec[A] {      
      def write(from: A): js.Any = w(from)
      def read(from: js.Any): A = r(from)
    }
    implicit val StringCodec: Codec[String] = Codec(s => s, _.asInstanceOf[String])
    implicit val IntCodec: Codec[Int] = Codec(s => s, _.asInstanceOf[Int])
    implicit val BooleanCodec: Codec[Boolean] = Codec(s => s, _.asInstanceOf[Boolean])    
    implicit def SeqCodec[A](implicit codec: Codec[A]): Codec[Seq[A]] = Codec(s => js.Array(s.map(codec.write) :_*), _.asInstanceOf[js.Array[js.Any]].toSeq.map(codec.read))
  }


$for(type)$
$if(type.plain)$
$for(type.constructor)$
  implicit object $type.name.pascal$ extends Codec[$type.name.pascal$] {
    def write(from: $type.name.pascal$): js.Any = js.Dynamic.literal(
$for(type.constructor.parameter)$
      "$type.constructor.parameter.name.raw$" -> Codec.write(from.$type.constructor.parameter.name.camel$)$sep$,
$endfor$

    )

    def read(from: js.Any): $type.name.pascal$ = from match {
      case from: js.Object => $type.name.pascal$(
$for(type.constructor.parameter)$
        Codec.read[$type.constructor.parameter.type$](from.asInstanceOf[js.Dictionary[js.Any]]("$type.constructor.parameter.name.raw$"))$sep$,
$endfor$

      )
    }
  }

$endfor$
$else$
$if(type.enum)$
  implicit object $type.name.pascal$Codec extends Codec[$type.name.pascal$] {
    def write(from: $type.name.pascal$): js.Any = from match {
$for(type.constructor)$
      case $type.name.pascal$.$type.constructor.name.pascal$ => "$type.constructor.name.raw$"
$endfor$
    }

    def read(from: js.Any): $type.name.pascal$ =       
     $for(type.constructor)$ if (from.asInstanceOf[String] == "$type.constructor.name.raw$") $type.name.pascal$.$type.constructor.name.pascal$$sep$
      else$endfor$
      else sys.error("invalid $type.name.raw$")    
  }
$else$
  implicit object $type.name.pascal$Codec extends Codec[$type.name.pascal$] {
    def write(from: $type.name.pascal$): js.Any = from match {
$for(type.constructor)$
$if(type.constructor.empty)$
      case $type.name.pascal$.$type.constructor.name.pascal$ => "$type.constructor.name.raw$"
$else$
      case $type.name.pascal$.$type.constructor.name.pascal$($for(type.constructor.parameter)$$type.constructor.parameter.name.camel$$sep$,$endfor$) => js.Dynamic.literal(
        "type" -> "$type.constructor.name.raw$",
$for(type.constructor.parameter)$
        "$type.constructor.parameter.name.raw$" -> Codec.write($type.constructor.parameter.name.camel$)$sep$,
$endfor$      

      )
$endif$    
$endfor$
    }

    def read(from: js.Any): $type.name.pascal$ = {
      val from_ = from.asInstanceOf[js.Dictionary[js.Any]]
     $for(type.constructor)$$if(type.constructor.empty)$ if (from.asInstanceOf[String] == "$type.constructor.name.raw$") $type.name.pascal$.$type.constructor.name.pascal$$else$ if (from_("type").asInstanceOf[String] == "$type.constructor.name.raw$") $type.name.pascal$.$type.constructor.name.pascal$(
$for(type.constructor.parameter)$
        Codec.read[$type.constructor.parameter.type$](from_("$type.constructor.parameter.name.raw$"))$sep$,
$endfor$

      )$endif$$sep$
      else$endfor$
      else sys.error("invalid $type.name.raw$")
    }  
  }
$endif$
$endif$
$sep$

$endfor$

}